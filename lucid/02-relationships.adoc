---
permalink: relationships
categories:
- lucid
---
= Relationships

toc::[]

关系数据库在管理多个数据库表之间的关系方面非常强大，Lucid通过提供的JavaScript的数据库关联来扩展此功能，这意味着您可以在不触及SQL模式的情况下定义两个表之间的关系。

== 基本例子
关系数据库旨在定义两个或多个数据库表之间的关系，定义关系有许多好处，因为它们使常见的数据库操作更容易。

让我们来看一个用户和一个配置文件模型的最常见的场景，数据库中的每个用户都可以拥有社交个人资料。我们称之为*一对一关系*。

要描述这种关系，您必须向用户模型添加以下代码行

.app/Model/User.js
[source, javascript]
----
'use strict'

const Lucid = use('Lucid')

class User extends Lucid {

  profile () {
    return this.hasOne('App/Model/Profile') <1>
  }

}
----

<1> `hasOne`方法定义给定模型上的一对一关系

现在您可以调用`profile`方法来访问指定用户的信息。

[source, javascript]
----
const user = yield User.find(1)
const userProfile = yield user.profile().fetch()
----

== 关系类型

=== 一对一
`hasOne` 关系定义了使用外键的2个模型之间的一对一关系。外键使用给定模型的唯一名称后跟*_id*创建。但是，您可以使用自己喜欢的方式替换他。

[options="header"]
|====
| 模型 | 外键
| User | user_id
| Seller | seller_id
|====

image:http://res.cloudinary.com/adonisjs/image/upload/v1472841270/has-one_zfrkve.jpg[]

要设置上图所示的关系，您需要在User模型中定义它。

==== hasOne(relatedModel, [primaryKey=id], [foreignKey=user_id])

.app/Model/User.js
[source, javascript]
----
class User extends Lucid {

  profile () {
    return this.hasOne('App/Model/Profile')
  }

}
----

=== 隶属关系（BelongsTo）
这种`belongsTo`关系是`hasOne`关系的反向关联，也依赖于外键。所以，记住它的最好的方法是用外键，任何具有外键关系的数据表，他的模型将始终具有`belongsTo`关系。

没有一个比较复杂的关系设计的规则，但是以最自然的方式设计他们总是很好，例如：

[options="header"]
|====
| 模型 | 关系 | 关联模型
| User | hasOne | Profile
| Profile | belongsTo | User
| Student | hasOne | IdCard
| IdCard | belongsTo | User
|====

希望这是有意义的，继续使用 *User* *Profile* 关系, Profile 模型将包含 `belongsTo` 关系来实现它所具有的外键关系。

==== belongsTo(relatedModel, [primaryKey=id], [foreignKey=user_id])

.app/Model/Profile.js
[source, javascript]
----
class Profile extends Lucid {

  user () {
    return this.belongsTo('App/Model/User')
  }

}
----

=== 一对多
您会发现自己`hasMany`经常使用，因为这是任何应用程序所需的最常见的关系。我们来看一些例子:

[options="header"]
|====
| 模型 | 关系 | 关联模型
| Book | hasMany | Chapter
| Chapter | belongsTo | Book
| Post | hasMany | Comment
| Comment | belongsTo | Post
|====

`hasMany` 关系使得每个主表记录通过各自的外键可以拥有多条想的记录在从表中

image:http://res.cloudinary.com/adonisjs/image/upload/v1472841272/has-many_p91i9i.jpg[]

> 译者注：上图表关系是错误的，已向原作者提交issue

我们来定义上述模型及其在Lucid中的关系：

==== hasMany(relatedModel, [primaryKey=id], [foreignKey=book_id])

.app/Model/Book.js
[source, javascript]
----
class Book extends Lucid {

  chapters () {
    return this.hasMany('App/Model/Chapter')
  }

}
----

.app/Model/Chapter.js
[source, javascript]
----
class Chapter extends Lucid {

  book () {
    return this.belongsTo('App/Model/Book')
  }

}
----

=== 隶属多个关系（BelongsToMany）
有些情况下，关系的每一边都可以在数据库中有很多相关的数据。我们来看一些例子

[options="header"]
|====
| 模型 | 关系 | 关联模型
| Student | belongsToMany | Courses
| Course | belongsToMany | Students
| Post | belongsToMany | Categories
| Category | belongsToMany | Posts
|====

以学生和课程为例，其中两个模型都可以在数据库中拥有许多相关的行数据。换句话说，这是一个多对多的关系

image:http://res.cloudinary.com/adonisjs/image/upload/v1472841273/belongsto-many_ymawpb.jpg[]

看上图，你会注意到有一个第三个表course_student。由于两端的每个模型有`hasMany`关系，所以它们之间不能设置对方的外键，而需要一个中间表。

第三个表被称为*枢轴表*，它拥有两个模型的外键，并定义了它们之间的独特关系。让我们在Lucid中定义这个关系，并查看可配置的选项。

==== belongsToMany(relatedModel, [pivotTable], [localKey], [otherKey])
.app/Model/Student.js
[source, javascript]
----
class Student extends Lucid {

  courses () {
    return this.belongsToMany('App/Model/Course')
  }

}
----

.app/Model/Course.js
[source, javascript]
----
class Course extends Lucid {

  students () {
    return this.belongsToMany('App/Model/Student')
  }

}
----

`belongsToMany` 方法接受多个参数来配置关系的表/字段

[options="header"]
|====
| 参数 | 必须 | 默认值
| pivotTable  | No | 数据透视表是每个模型名称的单数形式，按名称排列。例如，课程和学生模型将以course_student作为数据透视表名称。
| localKey  | No | 参考数据透视表内的模型外键
| otherKey  | No | 参考相关模型外键在数据透视表中
|====

==== withTimestamps()
携带时间戳
此外，您还可以选择在数据透视表上保存时间戳。

[source, javascript]
----
class Student extends Lucid {
  courses () {
    this.belongsToMany('App/Model/Course').withTimestamps()
  }
}
----

=== 远层一对多（HasManyThrough）
Lucid支持的另一个重要的关系类型是`hasManyThrough`,给定模型通过第三模型依赖于另一模型

image:http://res.cloudinary.com/adonisjs/image/upload/v1472841274/has-many-through_vux5jm.jpg[]

以某个国家的职位为例，想直接关联他们是不可能的，因为国家和职位之间没有直接的关系。但是在用户模型的帮助下，我们可以建立国家和职位之间的间接关系，这就是所谓的hasManyThrough关系。

.app/Model/Country.js
[source, javascript]
----
class Country extends Lucid {

  posts () {
    return this.hasManyThrough('App/Model/Post', 'App/Model/User')
  }

}
----

Now to fetch posts for a given country, you need to call the `posts` method on the *Country model*.

[source, javascript]
----
const country = yield Country.findBy('name', 'India')
const posts = yield country.posts().fetch()
response.json(posts)
----

The `hasManyThrough` method accepts given options.

[options="header"]
|====
| Parameter | Required  | Default Value
| relatedModel | Yes | null
| throughModel | Yes | null
| primaryKey | No | Model primary key
| foreignKey | No | Model foreign key
| throughPrimaryKey | No | Related model primary key
| throughForeignKey | No | Related model foreign key
|====

== Querying Relationships
Querying database for relationships is so straightforward and intuitive with Lucid. You just have to call defined relationship methods without worrying about the *join* queries.

Also querying relations is divided into three broad categories of *Lazy Loading*, *Eager Loading* and *Lazy Eager Loading*.

=== Lazy Loading
Lazy loading is a process of loading relationships after fetching the primary/parent record from the database

[source, javascript]
----
class User extends Lucid {

  profile () {
    return this.hasOne('App/Model/Profile')
  }

}
----

[source, javascript]
----
const user = yield User.find(1) <1>
const profile = yield user.profile().fetch() <2>
----

<1> First we `find` a user with the primary key.
<2> Then we call the previously defined `profile` method to fetch the related profile for the given user.

==== Defining Query Constraints
You can also attach query builder methods to your relationship definitions, and Lucid will make sure to execute them.

[source, javascript]
----
class User extends Lucid {

  profile () {
    return this
      .hasOne('App/Model/Profile')
      .where('is_active', true) <1>
  }

}
----

<1> Now when you will fetch the related profile for a given user, it will only include the record where is_active=true.

==== Runtime Query Constraints
You can also define runtime query constraints, just by chaining the query builder methods.

[source, javascript]
----
const user = yield User.find(1)
const profile = user
  .profile()
  .where('is_active', true)
  .fetch()
----

=== Eager Loading
Lazy loading may create *N+1* problem in certain scenarios. For example Loading profile for ten users, one by one will make a total of *11* queries. To eliminate this behavior you can preload/eager load profiles which will result in a total of *2* database queries.

[source, javascript]
----
const users = yield User
  .query()
  .with('profile') <1>
  .fetch()

console.log(users.toJSON())
----

.Output
[source, javascript]
----
[
  {
    id: 1,
    username: 'joe',
    email: '...',
    profile: {
      id: 4,
      avatar: '...'
    }
  }
]
----

<1> The `with` method can be used to eager load relationships with the parent record. Also, you can load multiple/nested relationships using the `with` method.

==== Eager Loading Multiple Relations

[source, javascript]
----
const users = yield User
  .query()
  .with('profile', 'friends')
  .fetch()
----

==== Eager Loading Nested Relations

[source, javascript]
----
const user = yield User
  .query()
  .with('friends.profile')
  .fetch()
----

==== Runtime Query Constraints
Also, you can build upon the query builder to filter the results from the related models.

[source, javascript]
----
const user = yield User
  .with('profile', 'friends')
  .scope('profile', (builder) => {
    builder.where('is_active', true)
  }) <1>
  .scope('friends', (builder) => {
    builder.orderBy('rank', 'desc')
  })
  .fetch()
----

<1> The `scope` method gives you the access to the query builder of the related model which means you can add `where` clause to filter the results.

=== Lazy Eager Loading
Lazy eager loading is a combination of xref:_lazy_loading[Lazy loading] and xref:_eager_loading[Eager Loading] instead of preloading all the relationships, you fetch the parent model instance and then eager load all related models.

[source, javascript]
----
const user = yield User.find(1)
yield user.related('profile', 'friends').load()

console.log(user.toJSON())
----

.Output
[source, javascript]
----
[
  {
    id: 1,
    username: 'joe',
    email: '...',
    profile: {
      id: 4,
      avatar: '...'
    }
  }
]
----

== Filtering Records

NOTE: Supported by adonis-lucid 3.0.13 or greater

A quite common use case is to filter top-level results based upon some conditions on a relationship. For example:

1. Display all users who have contributed at least one post.
2. Fetch all cars with 2 or more owners in a lifetime.

Ideally, it requires some complex joins, but Lucid makes it so easier for you.

==== has(relation, [expression], [value])

[source, javascript]
----
class User extends Lucid {

  posts () {
    return this.hasMany('App/Model/Post')
  }

}

// filtering
const users = yield User.query().has('posts').fetch()

// two or more
const users = yield User.query().has('posts', '>=', 2).fetch()
----

==== whereHas(relation, callback, [expression], [value])

[source, javascript]
----
const users = yield User.query().whereHas('posts', (builder) => {
  builder.where('is_published', true)
}).fetch()
----

Also, you can make use of `doesntHave` and `whereDoesntHave` methods, which are opposite of the above ones.

==== doesntHave(relation)

[source, javascript]
----
const users = yield User.query().doesntHave('friends').fetch()
----

==== whereDoesntHave(relation, callback)

[source, javascript]
----
const users = yield User.query().whereDoesntHave('friends', (builder) => {
  builder.where('is_verified', false)
}).fetch()
----

=== Counting Related Models
Getting counts of relationships is commonly used by web applications. For example: *Fetching comments count for every post*.

==== withCount(relation)

[source, javascript]
----
class Post extends Lucid {

  comments () {
    this.hasMany('App/Model/Comment')
  }

}

// fetching counts
const posts = yield Posts.query().withCount('comments').fetch()

console.log(posts.first().comments_count)
----

== Insert, Updates & Deletes
Relationships can also be *created*, *updated* and *deleted* with the same ease as fetching them. Whereas each relationship type has slightly different methods to persist related data.

==== save(modelInstance, [pivotValues])
The `save` method can be used to create/update related model instance. It works with following relations.

NOTE:: `pivotValues` are only supported by *belongsToMany* relationship. Checkout xref:_attach_rows_pivotvalues[attach] method documentation on how pivotValues are defined.

[support-list]
1. hasOne
2. hasMany
3. belongsToMany

[source, javascript]
----
const user = yield User.find(1)

const profile = new Profile()
profile.name = '@cybernox'
profile.avatar =  '...'

yield user.profile().save(profile)
----

==== create(values, [pivotValues])
The `create` method is almost similar to the `save` method whereas you pass an arbitrary object instead of passing a model instance.

[source, javascript]
----
const user = yield User.find(1)

yield user
  .profile()
  .create({name: '@cybernox', avatar: '...'})
----

==== saveMany(arrayOfInstances)
Save multiple related records for a given model instance. `saveMany` works with following relation types.

1. hasMany
2. belongsToMany

[source, javascript]
----
const user = yield User.find(1)

const profile = new Profile({name: '@cybernox'})
const anotherProfile = new Profile({name: '@jgwhite'})

yield user.profile.saveMany([profile, anotherProfile])
----

==== createMany(arrayOfValues)
The `createMany` method will also create multiple records whereas you pass an array of objects instead of model instances.

[source, javascript]
----
const user = yield User.find(1)
const profiles = yield user
  .profile()
  .createMany([{name: '@cybernox'}, {name: 'jgwhite'}])
----

==== attach(rows, [pivotValues])
The `attach` method only works with *belongsToMany* relationship. You attach existing records to form a relationship.

[source, javascript]
----
const student = yield Student.find(1)
const coursesIds = yield Courses.ids()

yield Student.courses().attach(coursesIds)
----

Optionally, you can pass an object to populate fields inside the *pivotTable*.

[source, javascript]
----
yield Student.courses().attach(coursesIds, {enrollment_confirmed: false})
----

Or you can also define different pivotValues for each related row.

[source, javascript]
----
const mathsId = yield Courses
  .query()
  .where('name', 'Maths')
  .pluckId()

const englishId = yield Courses
  .query()
  .where('name', 'English')
  .pluckId()

const enrollment = {}
enrollment[mathsId] = {enrollment_confirmed: true}
enrollment[englishId] = {enrollment_confirmed: false}

yield Student.courses().attach(enrollment)
----

==== detach(rows)
The `detach` method is the opposite of the xref:_attach_rows_pivot_values[attach] and will remove the relationships from pivotTable.

NOTE: The `detach` method does not remove the rows from the related model. It just removes the relationship from the pivot table.

[source, javascript]
----
const student = yield Student.find(1)
const coursesIds = yield Courses.ids()

yield Student.courses().detach(coursesIds)
----

==== sync(rows, [pivotValues])
The `sync` will remove all existing relations and will only add given relations. Think of it as calling xref:_detach_rows[detach] and xref:_attach_rows_pivot_values[attach] together.

TIP: You can also pass *pivotValues* to the sync method similar to the attach method.

[source, javascript]
----
const student = yield Student.find(1)
const coursesIds = yield Courses.ids()

yield Student.courses().sync(coursesIds)
----

==== updatePivot(values, [relatedModelId])
In order to update the values inside the pivot table you can make use of `updatePivot` method.

[source, javascript]
----
const student = yield Student.find(1)
Student.courses().updatePivot({marks: 90})
----

Or

[source, javascript]
----
const student = yield Student.find(1)
const maths = yield Course.where('name', 'Maths').first()
Student.courses().updatePivot({marks: 90}, maths.id)
----

==== withPivot(keys)
When fetching records for *belongsToMany* lucid will not select any rows from the pivot table. In order to fetch additional fields you can make use of `withPivot` method.

NOTE: Pivot table fields will be prefixed with `\_pivot_`. In below example the marks will be returned as `_pivot_marks`

[source, javascript]
----
'use strict'

class Student extends Lucid {

  courses () {
    return this.belongsToMany('App/Model/Course').withPivot('marks')
  }

}
----

Also you can define fields when running the select query.

[source, javascript]
----
const student = yield Student.find(1)
const courses = yield student.courses().withPivot('marks').fetch()
----

==== associate(modelInstance)
The `associate` method is used with *belongsTo* relationship to associate an existing database row.

[source, javascript]
----
const user = yield User.find(1)
const profile = new Profile()
profile.name = '@cybernox'

profile.user().associate(user)
yield profile.save()
----

==== dissociate
The `dissociate` method is the opposite of xref:_associate_model_instance[associate] and will remove the existing relationship

[source, javascript]
----
const profile = yield Profile.find(1)

profile.user().dissociate()
yield profile.save()
----
